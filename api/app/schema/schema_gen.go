// Code generated by https://github.com/shogo82148/myddlmaker; DO NOT EDIT.

//go:build !myddlmaker

package schema

import (
	"context"
	"database/sql"
)

type execer interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)
}

type queryer interface {
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
	PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)
}

func InsertUser(ctx context.Context, execer execer, values ...*User) error {
	const q = "INSERT INTO `user` (`name`, `email`, `password`, `created_at`, `updated_at`, `avatar`) VALUES (?, ?, ?, ?, ?, ?)" +
		", (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?)"
	const fieldCount = 6
	const maxStructCount = 32
	var args []any
	if len(values) >= maxStructCount {
		args = make([]any, 0, maxStructCount*fieldCount)
		err := func() error {
			stmt, err := execer.PrepareContext(ctx, q)
			if err != nil {
				return err
			}
			defer stmt.Close()

			for len(values) >= maxStructCount {
				vals, rest := values[:maxStructCount], values[maxStructCount:]
				args = args[:0]
				for _, v := range vals {
					args = append(args, v.Name, v.Email, v.Password, v.CreatedAt, v.UpdatedAt, v.Avatar)
				}
				if _, err := stmt.ExecContext(ctx, args...); err != nil {
					return err
				}
				values = rest
			}
			return nil
		}()
		if err != nil {
			return err
		}
	}
	if len(values) == 0 {
		return nil
	}
	if len(args) == 0 {
		args = make([]any, 0, len(values)*fieldCount)
	}
	args = args[:0]
	for _, v := range values {
		args = append(args, v.Name, v.Email, v.Password, v.CreatedAt, v.UpdatedAt, v.Avatar)
	}
	if _, err := execer.ExecContext(ctx, q[:len(values)*20+92], args...); err != nil {
		return err
	}
	return nil
}

func SelectUser(ctx context.Context, queryer queryer, primaryKeys *User) (*User, error) {
	var v User
	row := queryer.QueryRowContext(ctx, "SELECT `id`, `name`, `email`, `password`, `created_at`, `updated_at`, `avatar` FROM `user` WHERE `id` = ?", primaryKeys.ID)
	if err := row.Scan(&v.ID, &v.Name, &v.Email, &v.Password, &v.CreatedAt, &v.UpdatedAt, &v.Avatar); err != nil {
		return nil, err
	}
	return &v, nil
}

func SelectAllUser(ctx context.Context, queryer queryer) ([]*User, error) {
	var ret []*User
	rows, err := queryer.QueryContext(ctx, "SELECT `id`, `name`, `email`, `password`, `created_at`, `updated_at`, `avatar` FROM `user` ORDER BY `id`")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var v User
		if err := rows.Scan(&v.ID, &v.Name, &v.Email, &v.Password, &v.CreatedAt, &v.UpdatedAt, &v.Avatar); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func UpdateUser(ctx context.Context, execer execer, values ...*User) error {
	stmt, err := execer.PrepareContext(ctx, "UPDATE `user` SET `name` = ?, `email` = ?, `password` = ?, `created_at` = ?, `updated_at` = ?, `avatar` = ? WHERE `id` = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()
	for _, value := range values {
		if _, err := stmt.ExecContext(ctx, value.Name, value.Email, value.Password, value.CreatedAt, value.UpdatedAt, value.Avatar, value.ID); err != nil {
			return err
		}
	}
	return nil
}

func InsertPost(ctx context.Context, execer execer, values ...*Post) error {
	const q = "INSERT INTO `post` (`user_id`, `title`, `created_at`, `updated_at`, `img`) VALUES (?, ?, ?, ?, ?)" +
		", (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?), (?, ?, ?, ?, ?)"
	const fieldCount = 5
	const maxStructCount = 32
	var args []any
	if len(values) >= maxStructCount {
		args = make([]any, 0, maxStructCount*fieldCount)
		err := func() error {
			stmt, err := execer.PrepareContext(ctx, q)
			if err != nil {
				return err
			}
			defer stmt.Close()

			for len(values) >= maxStructCount {
				vals, rest := values[:maxStructCount], values[maxStructCount:]
				args = args[:0]
				for _, v := range vals {
					args = append(args, v.UserID, v.Title, v.CreatedAt, v.UpdatedAt, v.Img)
				}
				if _, err := stmt.ExecContext(ctx, args...); err != nil {
					return err
				}
				values = rest
			}
			return nil
		}()
		if err != nil {
			return err
		}
	}
	if len(values) == 0 {
		return nil
	}
	if len(args) == 0 {
		args = make([]any, 0, len(values)*fieldCount)
	}
	args = args[:0]
	for _, v := range values {
		args = append(args, v.UserID, v.Title, v.CreatedAt, v.UpdatedAt, v.Img)
	}
	if _, err := execer.ExecContext(ctx, q[:len(values)*17+80], args...); err != nil {
		return err
	}
	return nil
}

func SelectPost(ctx context.Context, queryer queryer, primaryKeys *Post) (*Post, error) {
	var v Post
	row := queryer.QueryRowContext(ctx, "SELECT `id`, `user_id`, `title`, `created_at`, `updated_at`, `img` FROM `post` WHERE `id` = ?", primaryKeys.ID)
	if err := row.Scan(&v.ID, &v.UserID, &v.Title, &v.CreatedAt, &v.UpdatedAt, &v.Img); err != nil {
		return nil, err
	}
	return &v, nil
}

func SelectAllPost(ctx context.Context, queryer queryer) ([]*Post, error) {
	var ret []*Post
	rows, err := queryer.QueryContext(ctx, "SELECT `id`, `user_id`, `title`, `created_at`, `updated_at`, `img` FROM `post` ORDER BY `id`")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var v Post
		if err := rows.Scan(&v.ID, &v.UserID, &v.Title, &v.CreatedAt, &v.UpdatedAt, &v.Img); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func UpdatePost(ctx context.Context, execer execer, values ...*Post) error {
	stmt, err := execer.PrepareContext(ctx, "UPDATE `post` SET `user_id` = ?, `title` = ?, `created_at` = ?, `updated_at` = ?, `img` = ? WHERE `id` = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()
	for _, value := range values {
		if _, err := stmt.ExecContext(ctx, value.UserID, value.Title, value.CreatedAt, value.UpdatedAt, value.Img, value.ID); err != nil {
			return err
		}
	}
	return nil
}

func InsertComment(ctx context.Context, execer execer, values ...*Comment) error {
	const q = "INSERT INTO `comment` (`post_id`, `user_id`, `text`, `created_at`, `updated_at`, `img`) VALUES (?, ?, ?, ?, ?, ?)" +
		", (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?)"
	const fieldCount = 6
	const maxStructCount = 32
	var args []any
	if len(values) >= maxStructCount {
		args = make([]any, 0, maxStructCount*fieldCount)
		err := func() error {
			stmt, err := execer.PrepareContext(ctx, q)
			if err != nil {
				return err
			}
			defer stmt.Close()

			for len(values) >= maxStructCount {
				vals, rest := values[:maxStructCount], values[maxStructCount:]
				args = args[:0]
				for _, v := range vals {
					args = append(args, v.PostID, v.UserID, v.Text, v.CreatedAt, v.UpdatedAt, v.Img)
				}
				if _, err := stmt.ExecContext(ctx, args...); err != nil {
					return err
				}
				values = rest
			}
			return nil
		}()
		if err != nil {
			return err
		}
	}
	if len(values) == 0 {
		return nil
	}
	if len(args) == 0 {
		args = make([]any, 0, len(values)*fieldCount)
	}
	args = args[:0]
	for _, v := range values {
		args = append(args, v.PostID, v.UserID, v.Text, v.CreatedAt, v.UpdatedAt, v.Img)
	}
	if _, err := execer.ExecContext(ctx, q[:len(values)*20+93], args...); err != nil {
		return err
	}
	return nil
}

func SelectComment(ctx context.Context, queryer queryer, primaryKeys *Comment) (*Comment, error) {
	var v Comment
	row := queryer.QueryRowContext(ctx, "SELECT `id`, `post_id`, `user_id`, `text`, `created_at`, `updated_at`, `img` FROM `comment` WHERE `id` = ?", primaryKeys.ID)
	if err := row.Scan(&v.ID, &v.PostID, &v.UserID, &v.Text, &v.CreatedAt, &v.UpdatedAt, &v.Img); err != nil {
		return nil, err
	}
	return &v, nil
}

func SelectAllComment(ctx context.Context, queryer queryer) ([]*Comment, error) {
	var ret []*Comment
	rows, err := queryer.QueryContext(ctx, "SELECT `id`, `post_id`, `user_id`, `text`, `created_at`, `updated_at`, `img` FROM `comment` ORDER BY `id`")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var v Comment
		if err := rows.Scan(&v.ID, &v.PostID, &v.UserID, &v.Text, &v.CreatedAt, &v.UpdatedAt, &v.Img); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func UpdateComment(ctx context.Context, execer execer, values ...*Comment) error {
	stmt, err := execer.PrepareContext(ctx, "UPDATE `comment` SET `post_id` = ?, `user_id` = ?, `text` = ?, `created_at` = ?, `updated_at` = ?, `img` = ? WHERE `id` = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()
	for _, value := range values {
		if _, err := stmt.ExecContext(ctx, value.PostID, value.UserID, value.Text, value.CreatedAt, value.UpdatedAt, value.Img, value.ID); err != nil {
			return err
		}
	}
	return nil
}

func InsertLike(ctx context.Context, execer execer, values ...*Like) error {
	const q = "INSERT INTO `like` (`post_id`, `user_id`) VALUES (?, ?)" +
		", (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?), (?, ?)"
	const fieldCount = 2
	const maxStructCount = 32
	var args []any
	if len(values) >= maxStructCount {
		args = make([]any, 0, maxStructCount*fieldCount)
		err := func() error {
			stmt, err := execer.PrepareContext(ctx, q)
			if err != nil {
				return err
			}
			defer stmt.Close()

			for len(values) >= maxStructCount {
				vals, rest := values[:maxStructCount], values[maxStructCount:]
				args = args[:0]
				for _, v := range vals {
					args = append(args, v.PostID, v.UserID)
				}
				if _, err := stmt.ExecContext(ctx, args...); err != nil {
					return err
				}
				values = rest
			}
			return nil
		}()
		if err != nil {
			return err
		}
	}
	if len(values) == 0 {
		return nil
	}
	if len(args) == 0 {
		args = make([]any, 0, len(values)*fieldCount)
	}
	args = args[:0]
	for _, v := range values {
		args = append(args, v.PostID, v.UserID)
	}
	if _, err := execer.ExecContext(ctx, q[:len(values)*8+47], args...); err != nil {
		return err
	}
	return nil
}

func SelectLike(ctx context.Context, queryer queryer, primaryKeys *Like) (*Like, error) {
	var v Like
	row := queryer.QueryRowContext(ctx, "SELECT `id`, `post_id`, `user_id` FROM `like` WHERE `id` = ?", primaryKeys.ID)
	if err := row.Scan(&v.ID, &v.PostID, &v.UserID); err != nil {
		return nil, err
	}
	return &v, nil
}

func SelectAllLike(ctx context.Context, queryer queryer) ([]*Like, error) {
	var ret []*Like
	rows, err := queryer.QueryContext(ctx, "SELECT `id`, `post_id`, `user_id` FROM `like` ORDER BY `id`")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var v Like
		if err := rows.Scan(&v.ID, &v.PostID, &v.UserID); err != nil {
			return nil, err
		}
		ret = append(ret, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return ret, nil
}

func UpdateLike(ctx context.Context, execer execer, values ...*Like) error {
	stmt, err := execer.PrepareContext(ctx, "UPDATE `like` SET `post_id` = ?, `user_id` = ? WHERE `id` = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()
	for _, value := range values {
		if _, err := stmt.ExecContext(ctx, value.PostID, value.UserID, value.ID); err != nil {
			return err
		}
	}
	return nil
}
